/**
 * Java8 Grammar
 *  Based on grammar from Java8 langauge specification
 *
 * [1] https://docs.oracle.com/javase/specs/jls/se8/html/jls-2.html#jls-2.4
 *
 * Authors:
 *   Kimio Kuramitsu (https://github.com/kkuramitsu/)
 *   Kohei Moriya
 */
File                               = _ { $(PackageDeclaration)? $(ImportDeclaration)* $(TypeDeclaration)* #Source } _ EOT

/* Code Layout (Whitespace) */
_                                  = ( S / BLOCKCOMMENT / LINECOMMENT )*
__                                 = !S
S                                  = [ \n\r\t\u000B\u000C]
BLOCKCOMMENT                       = '/*' ( !'*/' . )* '*/'
LINECOMMENT                        = '//' ( !'\n' . )*
EOL                                = '\r'? '\n'
                                   / !.
EOT                                = !.

/* Operators */
"++"                               = '++' _
"--"                               = '--' _
"&"                                = '&' ![&=] _
"*"                                = '*' !'=' _
"+"                                = '+' ![+=] _
"-"                                = '-' !( '-' / [=>] ) _
"~"                                = '~' _
"!"                                = '!' !'=' _
"{"                                = '{' _
"["                                = '[' _
"]"                                = ']' _
","                                = ',' _
"..."                              = '...' _
":"                                = ':' ![>:] _
"::"                               = '::' _
"/"                                = '/' !'=' _
"%"                                = '%' ![=>] _
"<<"                               = '<<' !'=' _
">>"                               = '>>' ![=>] _
">>>"                              = '>>>' !'=' _
"<="                               = '<=' _
">="                               = '>=' _
"<"                                = '<' ![=] _
">"                                = '>' ![=] _
"=="                               = '==' _
"!="                               = '!=' _
"^"                                = '^' ![=] _
"|"                                = '|' ![|=] _
"&&"                               = '&&' _
"||"                               = '||' _
"?"                                = '?' _
";"                                = ';' _
"}"                                = '}' _
"*="                               = '*=' _
"/="                               = '/=' _
"%="                               = '%=' _
"+="                               = '+=' _
"-="                               = '-=' _
"<<="                              = '<<=' _
">>="                              = '>>=' _
">>>="                             = '>>>=' _
"&="                               = '&=' _
"^="                               = '^=' _
"|="                               = '|=' _
"="                                = '=' !'=' _
"."                                = '.' !'.' _
"("                                = '(' _
")"                                = ')' _
"@"                                = '@' _
"->"                               = '->' _

// reserved keyword
"abstract"                         = 'abstract' !W _
"assert"                           = 'assert' !W _
"boolean"                          = 'boolean' !W _
"break"                            = 'break' !W _
"byte"                             = 'byte' !W _
"case"                             = 'case' !W _
"catch"                            = 'catch' !W _
"char"                             = 'char' !W _
"class"                            = 'class' !W _
"const"                            = 'const' !W _
"continue"                         = 'continue' !W _
"default"                          = 'default' !W _
"do"                               = 'do' !W _
"double"                           = 'double' !W _
"else"                             = 'else' !W _
"enum"                             = 'enum' !W _
"extends"                          = 'extends' !W _
"false"                            = 'false' !W _
"final"                            = 'final' !W _
"finally"                          = 'finally' !W _
"float"                            = 'float' !W _
"for"                              = 'for' !W _
"goto"                             = 'goto' !W _
"if"                               = 'if' !W _
"implements"                       = 'implements' !W _
"import"                           = 'import' !W _
"instanceof"                       = 'instanceof' !W _
"int"                              = 'int' !W _
"interface"                        = 'interface' !W _
"long"                             = 'long' !W _
"native"                           = 'native' !W _
"new"                              = 'new' !W _
"null"                             = 'null' !W _
"package"                          = 'package' !W _
"private"                          = 'private' !W _
"protected"                        = 'protected' !W _
"public"                           = 'public' !W _
"return"                           = 'return' !W _
"short"                            = 'short' !W _
"static"                           = 'static' !W _
"strictfp"                         = 'strictfp' !W _
"super"                            = 'super' !W _
"switch"                           = 'switch' !W _
"synchronized"                     = 'synchronized' !W _
"this"                             = 'this' !W _
"throw"                            = 'throw' !W _
"throws"                           = 'throws' !W _
"transient"                        = 'transient' !W _
"true"                             = 'true' !W _
"try"                              = 'try' !W _
"void"                             = 'void' !W _
"volatile"                         = 'volatile' !W _
"while"                            = 'while' !W _

/* Keyword */
KEYWORD                            = "abstract"
                                   / "assert"
                                   / "boolean"
                                   / "break"
                                   / "byte"
                                   / "case"
                                   / "catch"
                                   / "char"
                                   / "class"
                                   / "const"
                                   / "continue"
                                   / "default"
                                   / "double"
                                   / "do"
                                   / "else"
                                   / "enum"
                                   / "extends"
                                   / "false"
                                   / "final"
                                   / "finally"
                                   / "float"
                                   / "for"
                                   / "goto"
                                   / "if"
                                   / "implements"
                                   / "import"
                                   / "instanceof"
                                   / "interface"
                                   / "int"
                                   / "long"
                                   / "native"
                                   / "new"
                                   / "null"
                                   / "package"
                                   / "private"
                                   / "protected"
                                   / "public"
                                   / "return"
                                   / "short"
                                   / "static"
                                   / "strictfp"
                                   / "super"
                                   / "switch"
                                   / "synchronized"
                                   / "this"
                                   / "throws"
                                   / "throw"
                                   / "transient"
                                   / "true"
                                   / "try"
                                   / "void"
                                   / "volatile"
                                   / "while"

/* TopLevel */
TopLevel                           = PackageDeclaration
                                   / ImportDeclaration
                                   / TypeDeclaration
PackageDeclaration                 = { $anno(Annotations)? "package" $name(QualifiedName) #PackageDeclaration } ";"
ImportDeclaration                  = { "import" ("static" #StaticImportDeclaration / #ImportDeclaration) $name(PackageName) } ";"
PackageName                        = QualifiedName {$ "." "*" #WildCardName }?

TypeDeclaration                    = ClassDeclaration
                                   / InterfaceDeclaration
                                   / { ";" #Empty }

/* Annotation */
Annotations                        = { $(Annotation) $(Annotation)* #Modifiers }
Annotation                         = "@" { $key(QualifiedName) "(" $value(ElementValuePairList)? ")" #Annotation }
                                   / "@" { $key(QualifiedName) "(" $value(ElementValue) ")" #Annotation }
                                   / "@" { $key(QualifiedName) #Annotation }
ElementValuePairList               = { $(ElementValuePair) ( "," $(ElementValuePair) )* #List }
ElementValuePair                   = { $key(Identifier) "=" $value(ElementValue) #KeyValue }
ElementValue                       = ElementValueArrayInitializer
                                   / ConditionalExpression
                                   / Annotation
ElementValueArrayInitializer       = "{" { _ElementValueList? #List } ","? "}"
_ElementValueList                   = $(ElementValue) ( "," $(ElementValue) )*

example Annotations ~b791a3 @A @A() @A({1,2})

// Declaration
VariableDeclaration                = { $anno(VariableModifiers)? $type(Type) $list(InitDeclList) #VarDecl }
VariableModifier                   = Annotation
                                   / "final" { #Final }
VariableModifiers                  = { $(VariableModifier)+ #Modifiers }
InitDeclList                       = { $(InitDecl) ( "," $(InitDecl) )* #List }
InitDecl                           = { $name(VarName) ( "=" $expr(Initializer) )? #VarDecl }
VarName                            = Identifier {$name "[" $size(ConstantExpression)? "]" #ArrayName }*
Initializer                        = Expression
                                   / ArrayInitializer
ArrayInitializer                   = { "{" ( $(Initializer) ( "," $(Initializer) )* )? ","? "}" #List }

//class type, enum type
ClassDeclaration                   = { $(ClassModifiers)? "class" $(Identifier) $(TypeParameters)? $(SuperClass)? $(SuperInterfaces)* $(ClassBody) #ClassDeclaration }
                                   / { $(ClassModifiers)? "enum" $(Identifier) $(SuperInterfaces)* $(EnumBody) #EnumDeclaration }
ClassModifiers                     = { $(ClassModifier) $(ClassModifier)* #Modifiers }
ClassModifier                      = Annotation
                                   / { "public" #Public }
                                   / { "protected" #Protected }
                                   / { "private" #Private }
                                   / { "abstract" #Abstract }
                                   / { "final" #Final }
                                   / { "static" #Static }
                                   / { "strictfp" #Strictfp }
SuperClass                         = "extends" { $(ClassOrInterfaceType) #SuperClass }
SuperInterfaces                    = "implements" { $(ClassOrInterfaceTypes) #SuperInterfaces }
EnumBody                           = "{" { $(EnumeratorList)? ","? ";" $(ClassBodyDeclaration)+ #EnumBody } "}"
                                   / "{" { $(EnumeratorList)? ","? ";"? #EnumBody } "}"
EnumeratorList                     = { $(Enumerator) ( "," $(Enumerator) )* #List }
Enumerator                         = { $(Annotations)? $(Identifier) $({ "(" addArgumentExpressionList? ")" #List })? $(ClassBody)? #Enumerator }
ClassBody                          = "{" { $(ClassBodyDeclaration)* #ClassBody } "}"
ClassBodyDeclaration               = ClassMemberDeclaration
                                   / { $(Block) #InstanceInisializer }
                                   / "static" { $(Block) #StaticInitializer }
                                   / ConstructorDeclaration
ClassMemberDeclaration             = FieldDeclaration
                                   / MethodDeclaration
                                   / ClassDeclaration
                                   / InterfaceDeclaration
                                   / { ";" #Empty }

//interface, annotation type
InterfaceDeclaration               = { $(InterfaceModifiers)? "interface" $(Identifier) $(TypeParameters)? $(ExtendsInterfaces)* $(InterfaceBody) #InterfaceDeclaration }
                                   / { $(InterfaceModifiers)? "@" "interface" $(Identifier) $(AnnotationTypeBody) #AnnotationTypeDeclaration }
InterfaceModifier                  = Annotation
                                   / { "public" #Public }
                                   / { "protected" #Protected }
                                   / { "private" #Private }
                                   / { "abstract" #Abstract }
                                   / { "static" #Static }
                                   / { "strictfp" #Strictfp }
InterfaceModifiers                 = { $(InterfaceModifier) $(InterfaceModifier)* #List }
ExtendsInterfaces                  = { "extends" $(ClassOrInterfaceTypes) #ExtendsInterfaces }
InterfaceBody                      = "{" { $(InterfaceMemberDeclaration)* #InterfaceBody } "}"
InterfaceMemberDeclaration         = ConstantDeclaration
                                   / InterfaceMethodDeclaration
                                   / ClassDeclaration
                                   / InterfaceDeclaration
                                   / { ";" #Empty }
AnnotationTypeBody                 = "{" { $(AnnotationTypeMemberDeclaration)* #AnnotationTypeBody } "}"
AnnotationTypeMemberDeclaration    = AnnotationTypeElementDeclaration
                                   / ConstantDeclaration
                                   / ClassDeclaration
                                   / InterfaceDeclaration
                                   / { ";" #Empty }
AnnotationTypeElementDeclaration   = { $(AnnotationTypeElementModifiers)? $(Type) $(Identifier) "(" ")" $(AnnotationTypeElementDefaultValue)? ";" #AnnotationTypeElement }
AnnotationTypeElementModifier      = Annotation
                                   / "public" _ { #KeyValue $({ `visibility` #Key }) $({ `public` #Value }) }
                                   / "abstract" { #KeyValue $({ `abstraction` #Key }) $({ `abstract` #Value }) }
AnnotationTypeElementModifiers     = { $(AnnotationTypeElementModifier) $(AnnotationTypeElementModifier)* #List }
AnnotationTypeElementDefaultValue  = "default" ElementValue

//field, constant
FieldDeclaration                   = { $(FieldModifiers)? $(Type) $(InitDeclList) #Field } ";"
FieldModifiers                     = { $(FieldModifier) $(FieldModifier)* #Modifiers }
FieldModifier                      = Annotation
                                   / { "public" #Public }
                                   / { "protected" #Protected }
                                   / { "private" #Private }
                                   / { "final" #Final }
                                   / { "static" #Static }
                                   / { "transient" #Transient }
                                   / { "volatile" #Volatile }
ConstantDeclaration                = { $(ConstantModifiers)? $(Type) $(InitDeclList) #Constant } ";"
ConstantModifiers                  = { $(ConstantModifier) $(ConstantModifier)* #Modifiers }
ConstantModifier                   = Annotation
                                   / { "public" #Public }
                                   / { "protected" #Protected }
                                   / { "final" #Final }
                                   / { "static" #Static }

//method
MethodDeclaration                  = { $(MethodModifiers)? ( $(TypeParameters) $(Annotations)? )? $(TypeOrVoid) $(Identifier) "(" $(MethodParamList) ")" $(Throws)? ($(Block) / ";") #Method }
MethodModifiers                    = { $(MethodModifier) $(MethodModifier)* #Modifiers }
MethodModifier                     = Annotation
                                   / { "public" #Public }
                                   / { "protected" #Protected }
                                   / { "private" #Private }
                                   / { "final" #Final }
                                   / { "static" #Static }
                                   / { "synchronized" #Synchronized }
                                   / { "transient" #Transient }
                                   / { "volatile" #Volatile }
InterfaceMethodDeclaration         = { $(InterfaceMethodModifiers)? ( $(TypeParameters) $(Annotations)? )? $(TypeOrVoid) $(Identifier) "(" $(MethodParamList) ")" $(Throws)? ($(Block) / ";") #Method }
InterfaceMethodModifier            = Annotation
                                   / { "public" #Public }
                                   / { "protected" #Protected }
                                   / { "default" #Default }
                                   / { "static" #Static }
InterfaceMethodModifiers           = { $(InterfaceMethodModifier) $(InterfaceMethodModifier)* #List }
MethodParamList                    = { ( $(MethodParam) "," )* $(VarParam) #List }
                                   / { ( $(MethodParam) ( "," $(MethodParam) )* )? #List }
MethodParam                        = { $(VariableModifiers)? $(Type) $(VarName) #Param }
VarParam                           = { $(VariableModifiers)? $(Type) "..." $(VarName) #VarParam }
Throws                             = "throws" { $(ClassOrInterfaceTypes) #Throws }

//constructor
ConstructorDeclaration             = { $(ConstructorModifiers)? $(ReferenceType) "(" $(MethodParamList) ")" $(Throws)? $(ConstructorBody) #Constructor }
ConstructorModifiers               = { $(ConstructorModifier) $(ConstructorModifier)* #List }
ConstructorModifier                = Annotation
                                   / { "public" #Public }
                                   / { "protected" #Protected }
                                   / { "private" #Private }
ConstructorBody                    = { "{" $(ExplicitConstructorInvocation)? ( $(Statement) / $(LocalDeclaration) )* "}" #Block }
ExplicitConstructorInvocation      = { $(TypeArguments)? $({ $(This) "(" addArgumentExpressionList? ")" #List }) #ExplicitConstructorInvocation } ";"
                                   / { $(TypeArguments)? $({ $(Super) "(" addArgumentExpressionList? ")" #List }) #ExplicitConstructorInvocation } ";"
                                   / { $(PostfixExpression) "." $(TypeArguments)? $(Super) $({ "(" addArgumentExpressionList? ")" #List }) #ExplicitConstructorInvocation } ";"

/* Types, Values, Variables */
Type                               = ReferenceType
                                   / PrimitiveType
PrimitiveType                      = { $(Annotations) $(UnannoPrimitiveType) #Annotated }
                                   / UnannoPrimitiveType
UnannoPrimitiveType                = NumericType
                                   / BooleanType
NumericType                        = IntegralType
                                   / FloatingPointType
IntegralType                       = { "byte" #Tbyte }
                                   / { "char" #Tchar }
                                   / { "short" #Tshort }
                                   / { "int" #Tint }
                                   / { "long" #Tlong }
FloatingPointType                  = { "float" #Tfloat }
                                   / { "double" #Tdouble }
BooleanType                        = { "boolean" #Tboolean }
ReferenceType                      = ArrayType
                                   / ClassOrInterfaceType
                                   / TypeVariable
ArrayType                          = (PrimitiveType / ClassOrInterfaceType / TypeVariable) {$ $(Annotations)? "[" "]" #Tarray }+
ClassOrInterfaceType               = ClassType
                                   / InterfaceType

/* FIXME
 * ClassType
 *  {Annotation} Identifier [TypeArguments]
 *  ClassOrInterfaceType . {Annotation} Identifier [TypeArguments] */
ClassType                          = QualifiedName {$ $(TypeArguments) #Tparam }?
InterfaceType                      = ClassType
TypeVariable                       = { $(Annotations) $(Identifier) #Annotated }
                                   / Identifier
TypeParameter                      = { $(Annotations) $(UnannoTypeParameter) #Annotated }
                                   / UnannoTypeParameter
UnannoTypeParameter                = Identifier {$ "extends" $(ClassOrInterfaceType) ( "&" $(InterfaceType) )* #TypeBound }?
TypeParameters                     = { "<" $(TypeParameter) ( "," $(TypeParameter) )* ">" #TypeParameters }
TypeArgument                       = ReferenceType
                                   / { $(Annotations)? "?" #TWildCard } {$ ("extends" #UpperBound / "super" #LowerBound) $(ReferenceType) }?
TypeArguments                      = { "<" ( $(TypeArgument) ( "," $(TypeArgument) )* )? ">" #TypeArguments }
Void                               = { "void" #Tvoid }
TypeOrVoid                         = Type
                                   / Void
NonArrayType                       = ClassOrInterfaceType
                                   / PrimitiveType
ClassOrInterfaceTypes              = { $(ClassOrInterfaceType) ( "," $(ClassOrInterfaceType) )* #TypeList }

// Block, Statement
//===================
Block                              = { "{" ( $(Statement) / $(LocalDeclaration) )* "}" #Block }
LocalDeclaration                   = VariableDeclaration ";"
                                   / ClassDeclaration
Statement                          = Block
                                   / { "assert" $cond(Expression) ( ":" $msg(Expression) )? ";" #Assert }
                                   / { "if" "(" $cond(Expression) ")" $then(Statement) ( "else" $else(Statement) )? #If }
                                   / { "switch" "(" $cond(Expression) ")" $body(Statement) #Switch }
                                   / { "while" "(" $cond(Expression) ")" $body(Statement) #While }
                                   / { "do" $body(Statement) "while" "(" $cond(Expression) ")" ";" #DoWhile }
                                   / { "for" "(" $init(Expressions)? ";" $cond(Expression)? ";" $iter(Expressions)? ")" $body(Statement) #For }
                                   / { "for" "(" $init(VariableDeclaration) ";" $cond(Expression)? ";" $iter(Expressions)? ")" $body(Statement) #For }
                                   / { "for" "(" $anno(VariableModifiers)? $type(Type) $name(Identifier) ":" $iter(Expression) ")" $body(Statement) #ForEach }
                                   / { "goto" $label(Identifier) ";" #Goto }
                                   / { "continue" $label(Identifier)? ";" #Continue }
                                   / { "break" $label(Identifier)? ";" #Break }
                                   / { "return" $expr(Expression)? ";" #Return }
                                   / { "try" $(ResourceStatement) $(Block) $(CatchBlock)* $({ "finally" $(Block) #Finally })? #Try }
                                   / { "try" $(Block) $(CatchBlock)* $({ "finally" $(Block) #Finally }) #Try }
                                   / { "try" $(Block) $(CatchBlock)+ #Try }
                                   / { "throw" $expr(Expression) ";" #Throw }
                                   / { "synchronized" "(" $expr(Expression) ")" $body(Block) #Synchronized }
                                   / { "case" $cond(ConstantExpression) ":" ( !"case" !"default" $(Statement) )* #SwitchCase }
                                   / { "default" ":" ( !"case" $(Statement) )* #SwitchDefault }
                                   / { $label(Identifier) ":" #Label }
                                   / { $expr(Expression) ";" #Expression }
                                   / { ";" #Empty }

//trycatch
ResourceStatement                  = "(" { $(Resource) ( ";" $(Resource) )* #ResourceList } ";"? ")"
Resource                           = { $(VariableModifiers)? $(Type) $(Identifier) "=" $(Expression) #Declaration }
CatchBlock                         = { "catch" "(" $(CatchParameter) ")" $(Block) #Catch }
CatchParameter                     = { $(VariableModifiers)? $(ClassOrInterfaceType) $(Identifier) ( "|" $(Identifier) )* #Declaration }

/* Expression */
/* Unary Operator */
//format #Delete[1] `delete($[0])`
//format #Void[1] `void($[0])`
//format #TypeOf[1] `typeof($[0])`
/* Primary */
Expressions                        = { $(Expression) ( "," $(Expression) )* #List }
Expression                         = LambdaExpression
                                   / AssignmentExpression
AssignmentExpression               = { $left(UnaryExpression) _AssignmentOperator $right(Expression) }
                                   / ConditionalExpression
_AssignmentOperator                = "=" #Assign
                                   / "*=" #AssignMul
                                   / "/=" #AssignDiv
                                   / "%=" #AssignMod
                                   / "+=" #AssignAdd
                                   / "-=" #AssignSub
                                   / "<<=" #AssignLeftShift
                                   / ">>=" #AssignArithmeticRightShift
                                   / ">>>=" #AssignLogicalRightShift
                                   / "&=" #AssignBitwiseAnd
                                   / "^=" #AssignBitwiseXOr
                                   / "|=" #AssignBitwiseOr
ConstantExpression                 = ConditionalExpression
ConditionalExpression              = LogicalOrExpression {$cond "?" $then(Expression) ":" $else(LogicalOrExpression) #Conditional }*
LogicalOrExpression                = LogicalAndExpression {$left "||" $right(LogicalAndExpression) #Or }*
LogicalAndExpression               = InclusiveOrExpression {$left "&&" $right(InclusiveOrExpression) #And }*
InclusiveOrExpression              = ExclusiveOrExpression {$left "|" $right(ExclusiveOrExpression) #BitwiseOr }*
ExclusiveOrExpression              = AndExpression {$left "^" $right(AndExpression) #BitwiseXor }*
AndExpression                      = EqualityExpression {$left "&" $right(EqualityExpression) #BitwiseAnd }*
EqualityExpression                 = RelationalExpression {$left ("==" #Equals / "!=" #NotEquals) $right(RelationalExpression) }*
relationalOperator                 = "<=" #LessThanEquals
                                   / ">=" #GreaterThanEquals
                                   / "<" #LessThan
                                   / ">" #GreaterThan
RelationalExpression               = ShiftExpression {$left relationalOperator $right(ShiftExpression) / "instanceof" $right(ReferenceType) #InstanceOf }*
ShiftExpression                    = AdditiveExpression {$left ("<<" #LeftShift / ">>" #ArithmeticRightShift / ">>>" #LogicalRightShift) $right(AdditiveExpression) }*
AdditiveExpression                 = MultiplicativeExpression {$left ("+" #Add / "-" #Sub) $right(MultiplicativeExpression) }*
MultiplicativeExpression           = CastNewExpression {$left ("*" #Mul / "/" #Div / "%" #Mod) $right(CastNewExpression) }*
CastNewExpression                  = { "(" $type(Type) ")" $expr(CastNewExpression) #Cast }
                                   / UnaryExpression
UnaryExpression                    = PostfixExpression
                                   / { "++" $expr(UnaryExpression) #PrefixInc }
                                   / { "--" $expr(UnaryExpression) #PrefixDec }
                                   / { "+" $expr(CastNewExpression) #Plus }
                                   / { "-" $expr(CastNewExpression) #Minus }
                                   / { "~" $expr(CastNewExpression) #Compl }
                                   / { "!" $expr(CastNewExpression) #Not }
PostfixExpression                  = PrimaryExpression {$ addMethodCall / addInstanceCreation / addIndex / addField / addMethodReference / addInc / addDec }*
addMethodCall                      = "." $(TypeArguments)? $(Identifier) $({ "(" addArgumentExpressionList? ")" #List }) #Method
addInstanceCreation                = "." "new" $(TypeArguments)? $(Annotations)? $(ClassOrInterfaceType) $({ "(" addArgumentExpressionList? ")" #List }) $(ClassBody)? #InstanceCreation
addArgumentExpressionList          = $(Expression) ( "," $(Expression) )*
addIndex                           = "[" $(Expression) "]" #Index
addField                           = "." $(Identifier) !'(' #Field
addMethodReference                 = "::" $(TypeArguments)? $(Identifier) #MethodReference
addInc                             = "++" #Inc
addDec                             = "--" #Dec
PrimaryExpression                  = Constant
                                   / This
                                   / Super
                                   / "(" Expression ")"
                                   / ClassLiteral
                                   / { $(QualifiedName) "." "this" #This }
                                   / { $(QualifiedName) "." "super" #Super }
                                   / MethodInvocationExpression
                                   / InstanceCreationExpression
                                   / ArrayCreationExpression
                                   / MethodReference
                                   / Identifier
ClassLiteral                       = { $(TypeOrVoid) "." "class" #ClassLiteral }
This                               = { "this" #This }
Super                              = { "super" #Super }
MethodInvocationExpression         = { $(Identifier) $({ "(" addArgumentExpressionList? ")" #List }) #Method }
InstanceCreationExpression         = { "new" $(TypeArguments)? $(Annotations)? $(ClassOrInterfaceType) $({ "(" addArgumentExpressionList? ")" #List }) $(ClassBody)? #InstanceCreation }
ArrayCreationExpression            = { "new" $(Annotations)? $(NonArrayType {$ $(Annotations)? "[" $(Expression) "]" #ArraySize }+ {$ $(Annotations)? "[" "]" #ArraySize }*) #ArrayCreation }
                                   / { "new" $(Annotations)? $(NonArrayType {$ $(Annotations)? "[" "]" #ArraySize }+) $(ArrayInitializer) #ArrayCreation }
MethodReference                    = { $(ReferenceType) "::" $(TypeArguments)? $(Identifier / { "new" #Name }) #MethodReference }

LambdaExpression                   = { $(LambdaParameters) "->" $(LambdaBody) #Lambda }
LambdaParameters                   = { ($(Identifier) / $({ "(" addArgumentExpressionList? ")" #AddArgumentExpressionList }) / "(" $(InferredFormalParameterList) ")") #LambdaParameters }
InferredFormalParameterList        = { $(Identifier) ( "," $(Identifier) )* #InferredFormalParameterList }
LambdaBody                         = Expression
                                   / Block

/* Identifier */
//Name
//	= { NAME #Name } _
Identifier                         = { NAME #Name } _
QualifiedName                      = Identifier {$prefix "." $name(Identifier) #QualifiedName }*
W                                  = [a-zA-Z0-9_$]
NAME                               = !DIGIT !( KEYWORD !W ) W+

/* Literal, Constant */
//format #OctalInteger[0] `${text}`
//format #HexInteger[0] `${text}`
//format #RegExp[0] `${text}`
Literal                            = FloatingPointLiteral
                                   / IntegerLiteral
                                   / BooleanLiteral
                                   / CharacterLiteral
                                   / StringLiteral
                                   / NullLiteral
Constant                           = Literal
NullLiteral                        = {  #Null } "null"
BooleanLiteral                     = {  #True } "true"
                                   / { #False } "false" 
IntegerLiteral                     = { (DECIMAL / HEXADECIMAL / BINARY / OCTAL) (INT_SUFFIX #Long / FLOAT_SUFFIX #Float / #Integer) } _
DECIMAL                            = '0' ![bBxX0-9_]
                                   / [1-9] ( '_'* DIGIT )*
HEXADECIMAL                        = '0' [xX] HEX ( '_'* HEX )*
BINARY                             = '0' [bB] [01] ( '_'* [01] )*
OCTAL                              = '0' ( '_'* [0-7] )*
DIGIT                              = [0-9]
HEX                                = [a-fA-F0-9]
INT_SUFFIX                         = [lL]
FloatingPointLiteral               = { FLOAT #Double (FLOAT_SUFFIX #Float)? }  _
                                   / { DECIMAL #Double } FLOAT_SUFFIX _
FLOAT                              = FRACTION EXPONENT?
                                   / DIGIT+ EXPONENT
FLOAT_SUFFIX                       = [fFdD]
FRACTION                           = !'_' ( '_'* DIGIT )* '.' DIGIT ( '_'* DIGIT )*
                                   / DIGIT ( '_'* DIGIT )* '.'
EXPONENT                           = [eE] [+\-]? DIGIT ( '_'* DIGIT )*
StringLiteral                      = '"' { STRING_CONTENT* #String } '"' _
CharacterLiteral                   = '\'' { CHAR_CONTENT* #Character } '\'' _
STRING_CONTENT                     = ESCAPE
                                   / ![\"\n\\] .
CHAR_CONTENT                       = ESCAPE
                                   / !['\n\\] .
ESCAPE                             = SIMPLE_ESCAPE
                                   / OCTAL_ESCAPE
                                   / HEX_ESCAPE
SIMPLE_ESCAPE                      = '\\' ['\"\\bfnrt]
OCTAL_ESCAPE                       = '\\' [0-3] [0-7] [0-7]
                                   / '\\' [0-7] [0-7]
                                   / '\\' [0-7]
HEX_ESCAPE                         = '\\' 'u'+ HEX4
HEX4                               = HEX HEX HEX HEX

/* Example */

// The traditional "Hello, world!" program can be written in Java 
example TypeDeclaration&File '''
class HelloWorldApp {
    public static void main(String[] args) {
        System.out.println("Hello World!"); // Prints the string to the console.
    }
}
'''

// Generics
example File '''
package java.util.List;
public interface List<E> { 
    void add(E x);
    Iterator<E> iterator();
}
'''

// Annotation
example File '''
@Entity                                             // Declares this an entity bean
@Table(name = "people")                             // Maps the bean to SQL table "people"
public class Person implements Serializable {
    @Id                                             // Map this to the primary key column.
    @GeneratedValue(strategy = GenerationType.AUTO) // Database will generate new primary keys, not us.
    private Integer id;

    @Column(length = 32)                            // Truncate column values to 32 characters.
    private String name;
}
'''

// Generic Method
example MethodDeclaration '''
public void doSomething(List<? extends MyClass> list) {
  for(MyClass object : list) { // OK
    // do something
  }
}
'''

// Generic Method
example MethodDeclaration '''
public static <Type> Entry<Type, Type> twice(Type value) {
    return new Entry<Type, Type>(value, value);
}
'''

// Generics in throws clause
example MethodDeclaration '''
public <T extends Throwable> void throwMeConditional(boolean conditional, T exception) throws T {
    if(conditional) {
        throw exception;
    }
}
'''

/* Variable Declraration */

example VariableDeclaration '''
int a = 1
'''

example VariableDeclaration '''
int a = 1, b
'''

example VariableDeclaration '''
int[] anArray = { 
    1, 2,
    3, 4
}
'''

example VariableDeclaration '''
String[][] names = {
  {"Mr. ", "Mrs. ", "Ms. "},
  {"Smith", "Jones"}
}
'''

/* Statement */

example Statement '''
if(c);
'''

example Statement '''
if(c) {
}
'''

/* Expression (standard) */

example Expression ~7d9419 '''
1+2*3
'''

example Expression ~bfe331 '''
1*2+3
'''

example Expression ~162311 '''
(1+2)*3
'''

example Expression ~cd4f5d '''
1+2-3*4%5
'''

example Expression '''
x = x + 1
'''

example Expression '''
x = x | 1
'''

example Expression '''
x = x & 1
'''


/* Expression (local) */

example Expression '''
() -> {
  System.out.println("example");
}
'''

/* Identifier (standard) */

example Expression ~a47e9fd '''
x
''' 

example Expression  ~fdb051 '''
Apple
''' 

/* Literal (standard) */

example Literal ~1e4f2d '''
true
'''

example Literal ~4eab66 '''
false
'''

example Literal ~ec2775 '''
'C'
'''

example Literal ~1951c6 '''
0
'''

example Literal ~aef181 '''
26
'''

example Literal ~c3b9d6 '''
0x1a
'''

example Literal ~146f59 '''
0b11010
'''

example Literal ~f74a78 '''
123.4
'''

example Literal ~94b99c '''
1.234e2
'''

example Literal ~c83c217 '''
123.4f
'''

example Literal ~02bf7f6 '''
"hello,world\n"
'''

/* Literal (standard) */

example Literal ~db9f5e3 '''
"S\u00ED Se\u00F1or"
'''






format #PackageDeclaration[*] `package $[0];`
format #PackageDeclaration[*] `package $[0];`
format #ImportDeclaration[*] `import $[0];`
format #StaticImportDeclaration[*] `import static $[0];`
format #WildCardName[*] `$[0].*`
format #Modifiers[*] `$[0 ` ` -1] `
format #Annotation[*] `@$[0]($[1])`
format #Annotation[*] `@$[0]`
format #CommaList[*] `$[0 `, ` -1]`
format #KeyValue[*] `$[0] = $[1]`
format #Final[*] `final`
format #VarDecl[*] `$[0]`
format #VarDecl[*] `$[0] = $[1]`
format #VarName[*] `$[0][]`
format #VarName[*] `$[0][$[1]]`
format #Array[*] `{$[0 `, ` -1]}`
format #Annotated[*] `$[0] $[1]`
format #Tvoid[*] `void`
format #Tbyte[*] `byte`
format #Tshort[*] `short`
format #Tint[*] `int`
format #Tlong[*] `long`
format #Tfloat[*] `float`
format #Tdouble[*] `double`
format #Tarray[*] `$[0][]`
format #Tarray[*] `$[0] $[1] []`
format #TypeBound[*] `$[0] extends $[1] $[2 ` & ` -1]`
format #TypeArguments[*] `<$[0 `,` -1]>`
format #Comma[*] `$[0], $[1]`
format #Assign[*] `$[0] = $[1]`
format #AssignMul[*] `$[0] *= $[1]`
format #AssignDiv[*] `$[0] /= $[1]`
format #AssignMod[*] `$[0] %= $[1]`
format #AssignAdd[*] `$[0] += $[1]`
format #AssignSub[*] `$[0] -= $[1]`
format #AssignLeftShift[*] `$[0] <<= $[1]`
format #AssignRightShift[*] `$[0] >>= $[1]`
format #AssignLogicalRightShift[*] `$[0] >>>= $[1]`
format #AssignBitwiseAnd[*] `$[0] &= $[1]`
format #AssignBitwiseXOr[*] `$[0] ^= $[1]`
format #AssignBitwiseOr[*] `$[0] != $[1]`
format #Conditional[*] `$[0] ? $[1] : $[2]`
format #LogicalAnd[*] `$[0] && $[1]`
format #LogicalOr[*] `$[0] || $[1]`
format #BitwiseOr[*] `($[0] | $[1])`
format #BitwiseXor[*] `($[0] ^ $[1])`
format #BitwiseAnd[*] `($[0] & $[1])`
format #Equals[*] `$[0] == $[1]`
format #NotEquals[*] `$[0] != $[1]`
format #LessThanEquals[*] `$[0] <= $[1]`
format #LessThan[*] `$[0] < $[1]`
format #GreaterThanEquals[*] `$[0] >= $[1]`
format #GreaterThan[*] `$[0] > $[1]`
format #InstanceOf[*] `$[0] instanceof $[1]`
format #HashIn[*] `$[0] in $[1]`
format #LeftShift[*] `($[0] << $[1])`
format #RightShift[*] `($[0] >> $[1])`
format #LogicalRightShift[*] `($[0] >>> $[1])`
format #Add[*] `($[0] + $[1])`
format #Sub[*] `($[0] - $[1])`
format #Mul[*] `($[0] * $[1])`
format #Div[*] `($[0] / $[1])`
format #Mod[*] `($[0] % $[1])`
format #PrefixInc[*] `++$[0]`
format #PrefixDec[*] `--$[0]`
format #Plus[*] `+$[0]`
format #Minus[*] `-$[0]`
format #BitwiseNot[*] `~$[0]`
format #LogicalNot[*] `!$[0]`
format #SuffixInc[*] `$[0]++`
format #SuffixDec[*] `$[0]--`
format #This[*] `this`
format #Array[*] `[$[0 `,` -1]]`
format #Object[*] `{$[0 `,` -1]}`
format #Property[*] `$[0]: $[1]`
format #Field[*] `$[0].$[1]`
format #Index[*] `$[0][$[1]]`
format #List[*] `($[0 `, ` -1])`
format #Name[*] `${text}`
format #QualifiedName[*] `$[0].$[1]`
format #Null[*] `null`
format #True[*] `true`
format #False[*] `false`
format #Integer[*] `${text}`
format #Long[*] `${text}`
format #Float[*] `${text}`
format #Double[*] `${text}`
format #String[*] `"${text}"`
format #Character[*] `'${text}'`

// formatted by $ nez format
